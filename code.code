#include <QFile>
#include <QVector>
#include <QPushButton>
#include <QDebug>
#include <QCBOR.h>

class Block {
public:
    // Пример свойств класса:
    int id;
    QString name;
    
    // Конструктор
    Block(int id, QString name) : id(id), name(name) {}

    // Загрузка и сохранение в CBOR
    QCBORMap toCBOR() const {
        QCBORMap map;
        map.add("id", id);
        map.add("name", name);
        return map;
    }

    static Block fromCBOR(QCBORMap &map) {
        int id = map["id"].toInt();
        QString name = map["name"].toString();
        return Block(id, name);
    }
};

class MyClass : public QObject {
    Q_OBJECT
private:
    QVector<Block*> block_vector;

public:
    MyClass() {
        // Предположим, что мы заполнили block_vector некоторыми данными
        block_vector.append(new Block(1, "Block1"));
        block_vector.append(new Block(2, "Block2"));
    }

public slots:
    void saveToFile(const QString &fileName) {
        QCBORMap rootMap;
        rootMap.add("version", 1); // Версия файла

        QCBORArray blocksArray;
        for (Block* block : block_vector) {
            blocksArray.add(block->toCBOR());
        }
        rootMap.add("blocks", blocksArray);

        // Сохраняем в файл
        QFile file(fileName);
        if (!file.open(QIODevice::WriteOnly)) {
            qDebug() << "Ошибка открытия файла для записи.";
            return;
        }

        QCBORArray cborArray = rootMap.asCBOR();
        file.write(cborArray.toCbor());
        file.close();
    }

    void loadFromFile(const QString &fileName) {
        QFile file(fileName);
        if (!file.open(QIODevice::ReadOnly)) {
            qDebug() << "Ошибка открытия файла для чтения.";
            return;
        }

        QByteArray data = file.readAll();
        file.close();

        QCBORDecode decoder;
        const QCBORData decoded = decoder.decode(data);

        // Проверка версии
        int version = decoded.toMap()["version"].toInt();
        if (version != 1) {
            qDebug() << "Неверная версия файла.";
            return;
        }

        block_vector.clear(); // Очищаем текущий вектор

        QCBORArray blocksArray = decoded.toMap()["blocks"].toArray();
        for (auto blockItem : blocksArray) {
            QCBORMap blockMap = blockItem.toMap();
            Block block = Block::fromCBOR(blockMap);
            block_vector.append(new Block(block.id, block.name)); // Добавляем новый объект
        }
    }
};